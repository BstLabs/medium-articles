# Build user friendly CLI interface from pure python functions using DynaCLI

DynaCLI (Dynamic CLI) is a cloud-friendly Python library for converting pure Python functions into Linux Shell commands on the fly. 

This article explains how [DynaCLI](https://pypi.org/project/dynacli/) simplifies writing Command Line Interfaces in Python quickly and efficiently. It is a continuation of the article,[How to Write User-friendly Command Line Interfaces in Python](https://towardsdatascience.com/how-to-write-user-friendly-command-line-interfaces-in-python-cc3a6444af8e)
 which describes how to use different python libraries like  argparse, Click, Typer, Docopt and Fire to build CLI applications. To learn about the differences between DynaCLI and other alternatives mentioned above, refer [DynaCLI vs. Alternatives](https://bstlabs.github.io/py-dynacli/advanced/why/).

In this article, we will use the example explained in the original article and create an application for building a vaccination QR code with the user inputs provided as command line arguments. 

## Motivation 

The basic idea behind DynaCLI is to accelerate and automate the process of building CLI applications as much as possible allowing the focus to be only on the Python code. DynaCLI generates help messages from the Python function docstrings and the function arguments are converted to CLI commands.

Sounds interesting? Let's start .

## Conventional CLI building process 

Building CLIs, in general, is a two-step process: first - the core code and second - the CLI predefined as a set of arguments, as shown below. 

Let's start by looking at the code from the original [article]((https://towardsdatascience.com/how-to-write-user-friendly-command-line-interfaces-in-python-cc3a6444af8e)). In this code, they are first writing methods to implement the core code. 

```py
from dataclasses import dataclass, field, asdict
import requests
import shutil
from datetime import datetime

class ValidationException(Exception):
    pass

@dataclass
class Vaccination:
    manufacturer: str
    date: str

    def __post_init__(self):
        try:
            date = datetime.strptime(self.date, "%Y-%m-%d")
        except Exception:
            raise ValidationException("Vaccination date should be in format YYYY-MM-DD.")
        if date > datetime.today():
            raise ValidationException("Vaccination date should not be a future date.")
        if self.manufacturer.lower() not in ["pfizer","moderna","astrazeneca","janssen","sinovac"]:
            raise ValidationException("Your vaccine manufacturer is not approved.")

@dataclass
class QRCode:
    name: str
    birth: str
    vaccine: list[Vaccination] = field(default_factory=list)

def generate_qr_code(qr_code):
    code = asdict(qr_code)
    res = requests.get(f"http://api.qrserver.com/v1/create-qr-code/?data={code}", stream=True)
    if res.status_code == 200:
        with open("qr_code.png", "wb") as f:
            res.raw.decode_content = True
            shutil.copyfileobj(res.raw, f)
        return "QR code has been generated."
    else:
        raise Exception("QR code cannot be generated by QR Code Generator API.")
```

Then, following is the code needed to build CLI. This example uses argparse library (code snippet from referenced article) 

```py
def main():
    parser = argparse.ArgumentParser(description="Generate your vaccination QR code.")
    parser.add_argument("-n", "--name", type=str, help="Your name", required=True)
    parser.add_argument("-b", "--birth", type=str, help="Your birthday in YYYY-MM-DD format", required=True)
    parser.add_argument("-m", "--manufacturer", type=str, nargs="+", help="The vaccine manufacturer", required=True, choices=[
            "pfizer","moderna","astrazeneca","janssen","sinovac"])
    parser.add_argument("-d", "--date", type=str, nargs="+", help="The date of vaccination", required=True)
    args = parser.parse_args()
    
    if len(args.manufacturer) != len(args.date):
        logging.error(
            "The number of vaccine manufacturer doesn't match with the number of vaccine dates."
        )
        exit(1)
    
    qr_code = QRCode(name=args.name, birth=args.birth, vaccine=[Vaccination(args.manufacturer[i], args.date[i]) for i in range(len(args.date))])
    generate_qr_code(qr_code)

if __name__ == "__main__":
    try:
        main()
    except ValidationException as e:
        logging.error(e)
    except Exception as e:
        logging.exception(e)
```

## CLI Designing with DynaCLI
With Dynacli, we can skip the 2nd part by designing our functions to be CLI-friendly. Functionally, the core logic is the same. To demonstrate the differentiation, we will update the original code as shown below.  

### Restructuring
First off all, we would like to restructure the code. Thinking about CLI there should be `./qr-code` then `green-badge` feature-set(actual Python package) which is for storing all commands followed by `generate` to generate the actual QR codes:

```sh
$ tree green_badge -I __pycache__

green_badge
├── generate.py
└── __init__.py

```

From the original code, we know that the Vaccine manufacturers are a limited set of companies and this kind of information is best fit for Enum type.

```py
from enum import Enum

class Manufacturer(Enum):
    pfizer = 1
    moderna = 2
    astrazeneca = 3
    janssen = 4
    sinovac = 5

```

Or we can use [Literal](https://docs.python.org/3.9/library/typing.html#typing.Literal) -  and I am going to use it here in favor of Enum, by that we lose some guard but the clean interface is always beats and you can always add extra checks outside of the interface.

Therefore, we do not need manufacturer check in the `__post_init__` anymore and can remove it, going further, the whole purpose of `@dataclass` here, is the validation, we can replace them with [TypedDict](https://docs.python.org/3.9/library/typing.html#typing.TypedDict).

Our updated code `generate.py` file looks like:

```py
class Vaccination(TypedDict):
    date: datetime
    manufacturer: Literal["pfizer", "moderna", "astrazeneca", "janssen", "sinovac"]


class QRCode(TypedDict):
    name: str
    birth: str
    vaccination: list[Vaccination]
```
### CLI Building 
The second big step is to design actual `generate` function in a way that it is going to accept all necessary information as arguments:

```py
def generate(first_name: str, last_name: str, birthdate: str,  **vaccination: str) -> None:
    """
    Generate your vaccination QR code.

    Args:
        first_name (str): name of the vaccinated person
        last_name (str): surname of the vaccindate person
        birthdate (str): birthday of the vaccinated person in YYYY-MM-DD format
        **vaccination (str): vaccination information as date=manufacturer 

    Return: None
    """
    qr_code = QRCode(
        name=f"{first_name} {last_name}",
        birth=birthdate,
        vaccination=[
            Vaccination(manufacturer=manufacturer, date=datetime.strptime(date, "%Y-%m-%d"))
            for date, manufacturer in vaccination.items()
        ],
    )
    res = requests.get(
        f"http://api.qrserver.com/v1/create-qr-code/?data={qr_code}", stream=True
    )
    if res.status_code != 200:
        raise Exception("QR code cannot be generated by QR Code Generator API.")
    with open("qr_code.png", "wb") as f:
        res.raw.decode_content = True
        shutil.copyfileobj(res.raw, f)
    print("QR code has been generated.")
```
The major change is that we are going to accept date and the manufacturer name as key value pairs. This is quite intuitive, isn't it? The CLI call will look something like: `./qr-code green-badge generate Shako Rzayev 1989-10-24 2021-01-01=pfizer 2021-06-01=pfizer`
 
The next important difference is that DynaCLI populates help messages from the docstrings in the methods containing explanation of the arguments. You are right, quite Pythonic, if the explanations are already added once, why not use the same message to build the help messages in the CLI.  

The rest of the code is the same - functionally the code logic remains the same.

### CLI entrypoint

Now as the last step, create CLI entry point with Dynacli. Create a file called `cli` and add the following:

```py
#!/usr/bin/env python3

"""
Sample QR Generator
"""

import os
import sys

cwd = os.path.dirname(os.path.realpath(__file__))

__version__ = '1.0'

from dynacli import main

search_path = [cwd]
sys.path.extend(search_path)

main(search_path)
```
 
As you must have already noticed, there is no CLI pre-processing, adding arguments, version callback etc. Everything is dead simple Python. DynaCLI grabs version from __version__ and CLI name from cli docstring.

That is it, the changes are done and we are ready to run the CLI. Remember to give execution privileges to this file as:

```sh
$ chmod u+x qr-code
```

Getting help output:

```sh
$ ./qr-code -h

usage: qr-code [-h] [-v] {green-badge} ...

Sample QR Generator

positional arguments:
  {green-badge}
    green-badge  Generate Green Badge

optional arguments:
  -h, --help     show this help message and exit
  -v, --version  show program's version number and exit
```

The `green-badge` help message comes from the package `__init__.py` file:

```sh
$ cat green_badge/__init__.py 

"""
Generate Green Badge
"""

__version__ = "2.0"
```

Getting the version of the CLI itself:

```sh
$ ./qr-code --version

qr-code - v1.0
```
Now let's think about a different situation when you are porting an already developed package to be exposed by CLI, and it has its own version as v2.0 - should it mess up with the CLI version? It is not ideal to have a single version for the package and the CLI. 

With DynaCLI, you can version your packages and even modules. Again, it is quite Pythonic, just add `__version__` to package `__init__.py` and to the `generate.py` module itself.

```sh
$ ./qr-code green-badge --version

qr-code green-badge - v2.0
```

```sh
$ /qr-code green-badge generate --version

qr-code green-badge generate - v3.0
```

DynaCLI detects `generate.py` file and the `generate` function in it. Only public names are exposed by the CLI and the function docstring is used to register the help message.

Here, we would like to stress that, with DynaCLI, there is no need to begin writing things from the scratch and rewrite the whole code. All you need is to import already existing functionality to an intermediate representation as we did with `generate.py` and register it in the CLI. This effectively conforms to the [Open/Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle) where your original code is closed to modification but is open to be extended via CLI.

Our final version of `generate.py` looks like:

```py
import shutil
from datetime import datetime
from typing import Literal, TypedDict

import requests

__version__ = "3.0"

class Vaccination(TypedDict):
    date: datetime
    manufacturer: Literal["pfizer", "moderna", "astrazeneca", "janssen", "sinovac"]


class QRCode(TypedDict):
    name: str
    birth: str
    vaccination: list[Vaccination]


def generate(first_name: str, last_name: str, birthdate: str,  **vaccination: str) -> None:
    """
    Generate your vaccination QR code.

    Args:
        first_name (str): name of the vaccinated person
        last_name (str): surname of the vaccindate person
        birthdate (str): birthday of the vaccinated person in YYYY-MM-DD format
        **vaccination (str): vaccination information as date=manufacturer 

    Return: None
    """
    qr_code = QRCode(
        name=f"{first_name} {last_name}",
        birth=birthdate,
        vaccination=[
            Vaccination(manufacturer=manufacturer, date=datetime.strptime(date, "%Y-%m-%d"))
            for date, manufacturer in vaccination.items()
        ],
    )
    res = requests.get(
        f"http://api.qrserver.com/v1/create-qr-code/?data={qr_code}", stream=True
    )
    if res.status_code != 200:
        raise Exception("QR code cannot be generated by QR Code Generator API.")
    with open("qr_code.png", "wb") as f:
        res.raw.decode_content = True
        shutil.copyfileobj(res.raw, f)
    print("QR code has been generated.")
```

You can get help about the command using:

```py
$ ./qr-code green-badge generate -h
usage: qr-code green-badge generate [-h] first_name last_name birthdate [vaccination <name>=<value> ...]

positional arguments:
  first_name            name of the vaccinated person
  last_name             surname of the vaccindate person
  birthdate             birthday of the vaccinated person in YYYY-MM-DD format
  vaccination <name>=<value>
                        vaccination information as date=manufacturer

optional arguments:
  -h, --help            show this help message and exit
```

So, the **highlights of using DynaCLI** in this sample included: 
* We did not add or register any help messages - they were grabbed from the function docstrings.
* DynaCLI detects `**kwargs` and registers them as `<name>=<value>` pair.
* No special CLI pre-processing, adding arguments or version callbacks were required. 

Now, it is time to run the command and generate a qr code with the arguments provided:

```sh
$ ./qr-code green-badge generate Shako Rzayev 1989-10-24 2021-01-01=pfizer 2021-06-01=pfizer

QR code has been generated.
```

![QR](./code/qr_code.png)

That's it. We have focused only on the core functionality, simplified basic features of a CLI application and reshaped it to be more user- friendly and that is how the CLIs should be!
